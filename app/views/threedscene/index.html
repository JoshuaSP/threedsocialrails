
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Three DEE Social by Joshua & Kevin</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #fff;
				margin: 0px;
				padding: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				z-index:100;
			}

			.lbl { color:#fff; font-size:16px; font-weight:bold; position: absolute; bottom:0px; z-index:100; text-shadow:#000 1px 1px 1px; background-color:rgba(0,0,0,0.85); padding:1em }
			#lbl_left { text-align:left; left:0px }
			#lbl_right { text-align:left; right:0px }

			.g { color:#aaa }
			.c { color:#fa0 }

			a { color:red }

			/*#stats { position: absolute; top:0; left: 0 }
			#stats #fps { background: transparent !important }
			#stats #fps #fpsText { color: #777 !important }
			#stats #fps #fpsGraph { display: none }*/
		</style>
	</head>

	<body>
		<!-- <div id="info">
			<a href="http://threejs.org" target="_blank">three.js</a> - anisotropic texture filtering example
		</div> -->

		<div id="lbl_left" class="lbl">
		anisotropy: <span class="c" id="val_left"></span><br/>
		</div>

		<div id="lbl_right" class="lbl">
		anisotropy: <span class="c" id="val_right"></span><br/>
		</div>
<!--
		<script src="js/three.min.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
		<script src="fonts/helvetiker_regular.typeface.js"></script>
		<script src="node_modules/tween.js/index.js"> </script>

 -->
		<script>

			jk = {}
			// if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;

			var container;

			var camera, scene1, scene2, renderer;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var window_dance = []

			init();
			animate();


			function init() {


				container = document.createElement( 'div' );
				document.body.appendChild( container );

				renderer = new THREE.WebGLRenderer( { antialias: true } );

				//

				// camera = new THREE.PerspectiveCamera( 50, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 25000 );
				// camera.position.z = 0;

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 25000 );
				camera.position.z = 0;

				controls = new THREE.OrbitControls( camera );
				controls.damping = 0.2;
				controls.addEventListener( 'change', render );
				scene1 = new THREE.Scene();


				scene1.fog = new THREE.Fog( 0x9daaaa, .002, 100000);


				// scene1.add( new THREE.AmbientLight( 0xeef0ff ) );


				var light1 = new THREE.DirectionalLight( 0xffffff, .5 );
				light1.position.set( -8000, 1, 1 );
				scene1.add( light1 );

				var light2 = new THREE.DirectionalLight( 0xffffff, .4 );
				light1.position.set( 8000, 1, 1 );
				scene1.add( light2 );

				var light2 = new THREE.DirectionalLight( 0x999999, .4 );
				light1.position.set( 0, 800, 9000 );
				scene1.add( light2 );

				// Letters

				jk.textWidth = 50
				jk.textSize = 100
				jk.letterSpace = 10
				jk.spaceSpace = 40
				jk.letters = {}

				var chars = [].concat.apply( [], Array(94) )
              .map( function(_, i) {
								return String.fromCharCode(i+33)
							})
				letter_material = new THREE.MeshFaceMaterial( [
					new THREE.MeshPhongMaterial( {
						color: 0xaaaaff,
						shading: THREE.FlatShading,
						refractionRatio: 0.6,
						reflectivity: 0.2,
						specular: 0xffcccc,
						shininess: 50
					} ), // front
					new THREE.MeshPhongMaterial( { color: 0xaaaaff, shading: THREE.SmoothShading } ) // side
				] );

			// 	letter_material = new THREE.MeshBasicMaterial( {
      //       color: 0xccccff,
      //       refractionRatio: 0.6,
			// 			transparent: true,
			// 			opacity: 1
      // } );

				for(var i = 0; i < chars.length; i++) {
					letterGeo = new THREE.TextGeometry( chars[i], {
			  		size: jk.textSize,
			  		height: jk.textWidth,
			  		curveSegments: 3,
			  		font: "helvetiker",
			  		weight: "normal",
			  		style: "normal",
			  		material: 0,
			  		extrudeMaterial: 1
			  	});

			  	letterGeo.computeBoundingBox();
			  	letterGeo.computeVertexNormals();

			  	var centerOffset = -0.5 * ( letterGeo.boundingBox.max.x - letterGeo.boundingBox.min.x );
					jk.letters[chars[i]] = new THREE.Mesh( letterGeo, letter_material );
					console.log(chars[i])
				}


        //  TEXT

				jk.origin = new THREE.Vector3(0, 0, 0)
				jk.negativeZ = new THREE.Vector3(0,0,-1)
				jk.yaxis = new THREE.Vector3(0, 1, 0)

				camera.position.z = 4000

				flying_monkeys = 0
				meshes = {}

				var dispatcher = new WebSocketRails('localhost:3000/websocket');

				tweetChannel = dispatcher.subscribe('tweets')
				tweetChannel.bind('new', function(tweet) {
					var tweet_urls = /https?:\/\/t\.co\/\w{0,11}/g.exec(tweet)
					if(tweet_urls) {
						tweet_urls.forEach(function(tweet_url) {
							tweet.replace(tweet_url, '')
						})
					}
					dispatch_flying_monkey(tweet, tweet_urls)
				});

				create_flying_monkey = function (tweet, tweet_urls) {
					tweet_split = tweet.split("\n")
					flying_monkey = new THREE.Group()
					flying_monkey.userData.tweet_urls = tweet_urls
					for (var i = 0; i < tweet_split.length; i++) {
						monkey_piece = monkey_piece_factory(tweet_split[i])
						monkey_piece.position.setY(- jk.textSize * i * 1.5)
						flying_monkey.add(monkey_piece)
					}
					return flying_monkey
				}

				monkey_piece_factory = function (tweetline) {
					monkey_piece = new THREE.Group()
					var pos = 0
					tweetline.split("").forEach( function (tweetletter) {
						if (tweetletter == " ") {
							pos += jk.spaceSpace
						} else {
							if (jk.letters[tweetletter]) {
								new_letter = jk.letters[tweetletter].clone()
								new_letter.position.x = pos
								pos += new_letter.geometry.boundingBox.max.x + jk.letterSpace
								monkey_piece.add(new_letter)
							} else {
								// console.log("can't yet read: " + tweetletter)
							}
						}
					})
					return monkey_piece
				}

				jk.spawn_distance = new THREE.Vector3(0, 0, -5000 - Math.random() * 5000)


				dispatch_flying_monkey = function (tweet, tweet_urls) {
					console.log(tweet_urls)
					var flying_monkey = create_flying_monkey(tweet, tweet_urls)
					var entry_angle = Math.random() * 2 * Math.PI
					var vertical_angle = (0.5 - Math.random()) * Math.PI * (3/4)
					// var entry_height = Math.random() * 4000
					var startpos = jk.spawn_distance.clone()
					startpos.applyAxisAngle( jk.yaxis, entry_angle )
					var sp = startpos.clone().cross(jk.yaxis).normalize()
					// console.log(sp)
					startpos.applyAxisAngle( sp, vertical_angle)
					// var scale = Math.random() * 0.5 + .5
					// flying_monkey.scale = scale
					flying_monkey.position.copy(startpos)
					// flying_monkey.position.setY(entry_height)
					var time = Math.random() * 10000 + 25000
					var move_tween = new TWEEN.Tween(flying_monkey.position)
						.to( {x: 2 * startpos.x / 3, y: startpos.y + ( Math.random() - 0.5) * 4000, z: startpos.z + Math.random() * 2000}, 5000 + time)
						.onComplete(function() {
							scene1.remove(flying_monkey)
						})
						.start();

					flying_monkey.lookAt( jk.origin )
					scene1.add(flying_monkey)
				}
				//



				// RENDERER

				renderer.setClearColor( scene1.fog.color );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
				renderer.autoClear = false;

				renderer.domElement.style.position = "relative";
				container.appendChild( renderer.domElement );

				jk.raycaster = new THREE.Raycaster();
				jk.mouse = new THREE.Vector2();

			}

			function fetch_monkey_image(url) {
			// TODO  talk to the socket
			}


			function animate() {

				requestAnimationFrame( animate );
				TWEEN.update();
				render();
				// stats.update();
			}


			function render() {

				// update the picking ray with the camera and mouse position
				jk.raycaster.setFromCamera( jk.mouse, camera );
				// jk.raycaster.precision = 1
				// calculate objects intersecting the picking ray
				var intersects = jk.raycaster.intersectObjects( scene1.children, true );

				for ( var i = 0; i < intersects.length; i++ ) {

					//console.log(intersects[ i ].object.parent.parent);

				}

				renderer.clear();
				renderer.render( scene1, camera );
			}


		</script>

	</body>
</html>
